"""Pyramid combine layer for Player B.

This module defines :class:`~Q_Sea_Battle.PyrCombineLayerB`, a Keras layer used
to compute the next gun state and updated comm bit at each pyramid level.

The Step 1 implementation follows the Pyr dataset spec text:

- Next gun state is derived from the *even* positions and the shared-randomness
  outcome at that level.
- The comm bit is updated by XOR'ing with the parity contribution of the SR
  outcome gated by the gun being in the odd position of a pair.

Note:
    The QSeaBattle document mixes "gun" (one-hot in the game) with a binary
    vector state in the Pyr recursion. For Step 1 we implement the explicit
    per-pair formulas used for dataset generation.

Author: Rob Hendriks (spec)
Maintainer: autogenerated by ChatGPT
Version: 0.1
"""

from __future__ import annotations

from typing import Optional, Tuple

import tensorflow as tf


class PyrCombineLayerB(tf.keras.layers.Layer):
    """Compute Player B's next gun state and updated comm bit.

    Purpose:
        Given current gun state ``G^ℓ`` of length ``L`` (even), a shared
        randomness outcome ``S^ℓ`` of length ``L/2``, and a comm bit ``C^ℓ``,
        compute:

            G^{ℓ+1}[i] = G^ℓ[2*i] XOR S^ℓ[i]

        and update communication as:

            C^{ℓ+1} = C^ℓ XOR ( Σ_i (G^ℓ[2*i + 1] * S^ℓ[i]) mod 2 )

        The comm update corresponds to "append the SR outcome at the odd
        position if the gun is in that odd position; take parity", expressed
        as a vectorized gate-and-parity.

    Args:
        name: Optional Keras layer name.

    Call Args:
        gun_batch: Tensor of shape ``(B, L)`` with values in ``{0, 1}``.
        sr_outcome_batch: Tensor of shape ``(B, L/2)`` with values in ``{0, 1}``.
        comm_batch: Tensor of shape ``(B, 1)`` with values in ``{0, 1}``.

    Returns:
        Tuple ``(next_gun, next_comm)`` where:
            next_gun: Tensor of shape ``(B, L/2)`` in ``{0, 1}``.
            next_comm: Tensor of shape ``(B, 1)`` in ``{0, 1}``.
    """

    def __init__(self, name: Optional[str] = None) -> None:
        super().__init__(name=name, trainable=False)

    def call(
        self,
        gun_batch: tf.Tensor,
        sr_outcome_batch: tf.Tensor,
        comm_batch: tf.Tensor,
    ) -> Tuple[tf.Tensor, tf.Tensor]:
        """Combine gun state, shared randomness, and comm.

        Args:
            gun_batch: Tensor of shape ``(B, L)`` with values in ``{0, 1}``.
            sr_outcome_batch: Tensor of shape ``(B, L/2)`` with values in ``{0, 1}``.
            comm_batch: Tensor of shape ``(B, 1)`` with values in ``{0, 1}``.

        Returns:
            (next_gun, next_comm) as described in the class docstring.
        """
        g = tf.convert_to_tensor(gun_batch, dtype=tf.float32)
        sr = tf.convert_to_tensor(sr_outcome_batch, dtype=tf.float32)
        c = tf.convert_to_tensor(comm_batch, dtype=tf.float32)

        L = tf.shape(g)[-1]
        tf.debugging.assert_equal(L % 2, 0, message="Active length L must be even.")
        even = g[..., ::2]
        odd = g[..., 1::2]
        tf.debugging.assert_equal(
            tf.shape(even)[-1],
            tf.shape(sr)[-1],
            message="sr_outcome length must equal L/2.",
        )
        tf.debugging.assert_equal(
            tf.shape(c)[-1],
            1,
            message="comm_batch must have last dimension 1.",
        )

        next_gun = tf.math.floormod(even + sr, 2.0)

        # Gate SR outcomes by whether gun is at odd index in the pair, then take parity.
        gated = odd * sr
        parity = tf.math.floormod(tf.reduce_sum(gated, axis=-1, keepdims=True), 2.0)
        next_comm = tf.math.floormod(c + parity, 2.0)
        return next_gun, next_comm
