# PRAssisted

> Role: Stateful two-party PR-assisted resource that returns a uniformly random first outcome string and a second outcome string biased-correlated to the first based on both parties’ measurement settings and `p_high`.

Location: `Q_Sea_Battle.pr_assisted.PRAssisted`

## Constructor

Parameter | Type | Description
--- | --- | ---
length | int, constraint $length \ge 1$ | Number of bits in each measurement/outcome string.
p_high | float, constraint $0.0 \le p\_high \le 1.0$ | Correlation parameter controlling how likely the second outcome matches (or complements) the first outcome per index.

Preconditions

- `length` is `int`, constraint $length \ge 1$.
- `p_high` is `int` or `float`, convertible to `float`, constraint $0.0 \le p\_high \le 1.0$.

Postconditions

- `self.length` is set to `length`.
- `self.p_high` is set to `float(p_high)`.
- Measurement state is reset: `a_measured == False`, `b_measured == False`, and previous-measurement/outcome fields are `None`.
- A NumPy RNG is created and stored in `self._rng`.

Errors

- Raises `TypeError` if `length` is not an `int`.
- Raises `ValueError` if `length < 1`.
- Raises `TypeError` if `p_high` is not an `int` or `float`.
- Raises `ValueError` if `p_high` is outside $[0.0, 1.0]$.

Example

!!! example "Construct and use in a single round"
    ```python
    import numpy as np
    from Q_Sea_Battle.pr_assisted import PRAssisted

    pr = PRAssisted(length=4, p_high=0.8)

    x_a = np.array([0, 1, 0, 1], dtype=int)
    x_b = np.array([1, 1, 0, 0], dtype=int)

    out_a = pr.measurement_a(x_a)
    out_b = pr.measurement_b(x_b)

    pr.reset()
    ```

## Public Methods

### measurement_a(measurement)

Perform a measurement by party A.

Arguments

- measurement: np.ndarray, dtype int, values in {0,1}, shape (length,), 1D measurement setting vector.

Returns

- np.ndarray, dtype int, values in {0,1}, shape (length,), 1D outcome vector for party A.

Preconditions

- `self.a_measured` is `False` for the current round.
- `measurement` is valid per `_validate_measurement`: coercible to 1D `int` array, shape `(length,)`, values in `{0,1}`.

Postconditions

- `self.a_measured` is set to `True`.
- If this is the first measurement of the round: `prev_party`, `prev_measurement`, and `prev_outcome` are stored and the returned outcome is uniformly random in `{0,1}^{length}`.
- If this is the second measurement of the round: the returned outcome is generated by `_second_measurement(...)` using stored previous measurement/outcome.

Errors

- Raises `ValueError` if A already measured in the current round.
- Raises `ValueError` if `measurement` is not 1D, not shape `(length,)`, or contains values outside `{0,1}`.

Example

!!! example "A measures first"
    ```python
    import numpy as np
    from Q_Sea_Battle.pr_assisted import PRAssisted

    pr = PRAssisted(length=3, p_high=0.9)
    out_a = pr.measurement_a(np.array([0, 0, 1], dtype=int))
    ```

### measurement_b(measurement)

Perform a measurement by party B.

Arguments

- measurement: np.ndarray, dtype int, values in {0,1}, shape (length,), 1D measurement setting vector.

Returns

- np.ndarray, dtype int, values in {0,1}, shape (length,), 1D outcome vector for party B.

Preconditions

- `self.b_measured` is `False` for the current round.
- `measurement` is valid per `_validate_measurement`: coercible to 1D `int` array, shape `(length,)`, values in `{0,1}`.

Postconditions

- `self.b_measured` is set to `True`.
- If this is the first measurement of the round: `prev_party`, `prev_measurement`, and `prev_outcome` are stored and the returned outcome is uniformly random in `{0,1}^{length}`.
- If this is the second measurement of the round: the returned outcome is generated by `_second_measurement(...)` using stored previous measurement/outcome.

Errors

- Raises `ValueError` if B already measured in the current round.
- Raises `ValueError` if `measurement` is not 1D, not shape `(length,)`, or contains values outside `{0,1}`.

Example

!!! example "B measures second"
    ```python
    import numpy as np
    from Q_Sea_Battle.pr_assisted import PRAssisted

    pr = PRAssisted(length=2, p_high=0.7)
    out_a = pr.measurement_a(np.array([1, 0], dtype=int))
    out_b = pr.measurement_b(np.array([1, 1], dtype=int))
    ```

### reset()

Reset internal measurement state for reuse of the resource.

Arguments

- None.

Returns

- None.

Postconditions

- `a_measured == False`
- `b_measured == False`
- `prev_party is None`
- `prev_measurement is None`
- `prev_outcome is None`

Errors

- Not specified.

Example

!!! example "Reset between rounds"
    ```python
    from Q_Sea_Battle.pr_assisted import PRAssisted

    pr = PRAssisted(length=1, p_high=0.5)
    pr.reset()
    ```

## Data & State

Public attributes

- length: int, constraint $length \ge 1$, scalar, number of bits in each measurement/outcome string.
- p_high: float, constraint $0.0 \le p\_high \le 1.0$, scalar, correlation parameter.
- a_measured: bool, scalar, whether party A has measured in the current round.
- b_measured: bool, scalar, whether party B has measured in the current round.
- prev_party: Optional[str], constraint in {"a","b"} when not None, scalar, party label of the first measurer for the current round.
- prev_measurement: Optional[np.ndarray], dtype int, values in {0,1}, shape (length,), first party’s measurement vector for the current round when set.
- prev_outcome: Optional[np.ndarray], dtype int, values in {0,1}, shape (length,), first party’s outcome vector for the current round when set.

Private/internal attributes

- _rng: numpy.random.Generator, RNG used for uniform bit generation and per-index Bernoulli draws.

State model (round semantics)

- A “round” consists of up to two successful measurements, at most one by A and at most one by B, in either order; `reset()` clears the round state.

## Planned (design-spec)

- Not specified.

## Deviations

- Not specified.

## Notes for Contributors

- The first successful measurement in a round stores `prev_measurement` and `prev_outcome`; the second successful measurement uses those stored arrays to generate correlated outcomes; `reset()` must be called to reuse the instance for a new round.
- Input validation is centralized in `_validate_measurement`, which coerces inputs using `np.asarray(..., dtype=int)`; callers can pass array-like inputs as long as they coerce to a valid 1D 0/1 vector of length `length`.

## Related

- `SharedRandomness` in `shared_randomness.py` (mentioned in the module docstring as functionally identical; not present in this module text).

## Changelog

- Version 0.1: Initial implementation of `PRAssisted` (as indicated by the module docstring).